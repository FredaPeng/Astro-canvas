<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Match: NOIRLab Edition</title>
    <style>
        :root {
            --bg: #0b0d17;
            --accent: #00f3ff;
            --glass: rgba(255, 255, 255, 0.1);
        }
        body { margin: 0; background: var(--bg); overflow: hidden; font-family: 'Courier New', Courier, monospace; user-select: none; }
        
        /* --- LAYOUT --- */
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; position: absolute; top:0; left:0; z-index: 2; }
        
        /* --- HUD ELEMENTS --- */
        #hud {
            position: absolute; top: 30px; left: 30px; z-index: 20;
            pointer-events: none; /* Let clicks pass through */
        }
        
        h1 { 
            color: white; margin: 0; 
            font-size: 24px; letter-spacing: 4px; 
            text-transform: uppercase; 
            text-shadow: 0 0 10px var(--accent);
        }
        
        #status-box {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 10, 20, 0.8);
            border-left: 3px solid var(--accent);
            color: var(--accent);
            font-size: 14px;
            max-width: 300px;
            transition: all 0.3s ease;
        }

        /* --- THE DISCOVERY LINK --- */
        #discovery-link {
            display: none; /* Hidden by default */
            margin-top: 15px;
            pointer-events: auto; /* Enable clicking */
            background: var(--accent);
            color: #000;
            padding: 12px 20px;
            text-decoration: none;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 15px var(--accent);
            border-radius: 2px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #discovery-link:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--accent);
        }
        #discovery-link::after {
            content: " â†—"; /* Arrow icon */
        }

        /* --- CONTROLS --- */
        #controls {
            position: absolute; top: 30px; right: 30px; z-index: 20;
            display: flex; gap: 10px;
        }
        .mode-btn {
            background: rgba(0,0,0,0.6); 
            border: 1px solid rgba(255,255,255,0.3); 
            color: white;
            padding: 10px 20px; 
            cursor: pointer; 
            text-transform: uppercase;
            transition: 0.3s;
        }
        .mode-btn:hover, .mode-btn.active { 
            background: var(--accent); 
            color: black; 
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent);
        }

        /* --- SPECTRUM MODE --- */
        #spectrum-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; opacity: 0; transition: opacity 0.5s;
            background: radial-gradient(circle at center, transparent 0%, #000 100%);
        }
        
        /* --- TELESCOPE MODAL --- */
        #photo-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 50;
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
        }
        #photo-modal img {
            max-width: 80%; max-height: 70%;
            border: 2px solid white;
            box-shadow: 0 0 50px rgba(255,255,255,0.1);
        }
        #photo-caption {
            color: white; margin-top: 20px; font-size: 18px; letter-spacing: 2px;
        }
        #close-modal {
            margin-top: 20px;
            background: transparent; border: 1px solid white; color: white;
            padding: 10px 30px; cursor: pointer;
        }
        #close-modal:hover { background: white; color: black; }

    </style>
</head>
<body>

<div id="container">
    <div id="controls">
        <button class="mode-btn active" onclick="setMode('draw')">Constellation Draw</button>
        <button class="mode-btn" onclick="setMode('color')">Spectrum Search</button>
    </div>

    <div id="hud">
        <h1>Stellar Match</h1>
        <div id="status-box">
            System Ready.<br>
            Draw a shape (Line, V, Hook, Triangle).
        </div>
        <a id="discovery-link" href="#" target="_blank">View Data Record</a>
    </div>

    <canvas id="main-canvas"></canvas>
    <div id="spectrum-layer"></div>

    <div id="photo-modal">
        <img id="reveal-img" src="" alt="Space Discovery">
        <div id="photo-caption"></div>
        <button id="close-modal" onclick="closePhoto()">Close Telescope View</button>
    </div>
</div>

<script>
    // ==========================================
    // 1. DATASETS (With NOIRLab Slugs)
    // ==========================================
    
    const constellations = [
        {
            name: "Orion's Belt",
            slug: "orion", // URL slug for noirlab.edu
            // Shape: Straight Line (3 stars)
            points: [[0, 0.5], [0.5, 0.5], [1, 0.5]],
            color: "#4facfe"
        },
        {
            name: "Ursa Major (Handle)",
            slug: "ursa-major",
            // Shape: Gentle Arc
            points: [[0, 0.2], [0.33, 0.4], [0.66, 0.45], [1, 0.3]],
            color: "#f093fb"
        },
        {
            name: "Cassiopeia",
            slug: "cassiopeia",
            // Shape: Zig-Zag / V
            points: [[0, 0], [0.3, 1], [0.6, 0.2], [1, 0.8]],
            color: "#fee140"
        },
        {
            name: "Scorpius (Tail)",
            slug: "scorpius",
            // Shape: Hook / J
            points: [[0.2, 0], [0.2, 0.6], [0.5, 1], [1, 0.8]],
            color: "#ff0844"
        },
        {
            name: "Triangulum",
            slug: "triangulum",
            // Shape: Closed Triangle
            points: [[0, 0], [0.5, 1], [1, 0], [0, 0]], 
            color: "#00f2fe"
        },
        {
            name: "Caelum (Chisel)",
            slug: "caelum",
            // Shape: Slight curved line
            points: [[0.2, 0], [0.3, 0.5], [0.4, 1]],
            color: "#00ff9d"
        }
    ];

    const telescopePhotos = [
        { hue: 10,  url: "https://apod.nasa.gov/apod/image/1907/CarinaMst_Perez_1080.jpg", name: "Carina Nebula (Red)" },
        { hue: 220, url: "https://apod.nasa.gov/apod/image/2108/VeilNebula_idark_960.jpg", name: "Veil Nebula (Blue/Purple)" },
        { hue: 120, url: "https://apod.nasa.gov/apod/image/2011/Tarantula-HST-ESO-Webb-LL.jpg", name: "Tarantula Nebula (Green)" },
        { hue: 45,  url: "https://apod.nasa.gov/apod/image/2004/Reef_Hubble_960.jpg", name: "Cosmic Reef (Orange)" }
    ];

    // ==========================================
    // 2. CORE SETUP
    // ==========================================
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    const statusBox = document.getElementById('status-box');
    const discoveryLink = document.getElementById('discovery-link');
    const spectrumLayer = document.getElementById('spectrum-layer');
    const photoModal = document.getElementById('photo-modal');

    let mode = 'draw';
    let width, height;

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        if(mode === 'draw') renderStarField();
    }
    window.addEventListener('resize', resize);
    resize();

    function setMode(m) {
        mode = m;
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        // Find the button with the matching onclick and add active class (simple way)
        const buttons = document.querySelectorAll('.mode-btn');
        if(m === 'draw') buttons[0].classList.add('active');
        else buttons[1].classList.add('active');

        if (mode === 'draw') {
            spectrumLayer.style.opacity = 0;
            canvas.style.pointerEvents = "auto";
            statusBox.innerHTML = "System Ready.<br>Draw a shape.";
            discoveryLink.style.display = "none";
            renderStarField();
        } else {
            spectrumLayer.style.opacity = 1;
            canvas.style.pointerEvents = "none";
            statusBox.innerHTML = "Spectrum Search.<br>Move mouse. Double-click to lock.";
            discoveryLink.style.display = "none";
            ctx.clearRect(0,0,width,height);
        }
    }

    // ==========================================
    // 3. DRAWING & MATCHING LOGIC
    // ==========================================
    let isDrawing = false;
    let rawPath = [];

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', drawMove);
    canvas.addEventListener('mouseup', endDraw);

    function startDraw(e) {
        if(mode !== 'draw') return;
        isDrawing = true;
        rawPath = [{x: e.clientX, y: e.clientY}];
        discoveryLink.style.display = "none"; // Hide previous link
        statusBox.innerHTML = "Acquiring signal...";
        
        renderStarField(); // Clear previous
        
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 2;
        ctx.moveTo(e.clientX, e.clientY);
    }

    function drawMove(e) {
        if(!isDrawing) return;
        const p = {x: e.clientX, y: e.clientY};
        rawPath.push(p);
        
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
    }

    function endDraw() {
        isDrawing = false;
        if(rawPath.length < 5) return;

        // --- OPTIMIZED MATCHING ALGORITHM ---
        
        // 1. Normalize user input to 20 equidistant points in a 0-1 box
        const inputVector = normalizePath(rawPath, 20);

        // 2. Find best fit
        let bestMatch = null;
        let bestScore = Infinity;

        constellations.forEach(constell => {
            // Normalize database shape on the fly (or pre-compute in real app)
            // Convert database array-of-arrays to array-of-objects for the helper
            const dbPathObj = constell.points.map(p => ({x: p[0], y: p[1]}));
            const dbVector = normalizePath(dbPathObj, 20, true); // true = already 0-1 scale

            const score = getScore(inputVector, dbVector);
            
            if (score < bestScore) {
                bestScore = score;
                bestMatch = constell;
            }
        });

        // 3. Threshold (Strictness)
        // 0.25 allows for some loose sketching. 0.1 requires precision.
        if (bestScore < 0.3) {
            snapToMatch(bestMatch, rawPath);
        } else {
            statusBox.innerHTML = "Signal unclear.<br>Try drawing a simpler line or hook.";
        }
    }

    // --- ALGORITHM HELPERS ---

    function normalizePath(points, targetCount, isAlreadyScaled = false) {
        // A. Calculate total length
        let len = 0;
        for(let i=0; i<points.length-1; i++) {
            len += Math.hypot(points[i+1].x - points[i].x, points[i+1].y - points[i].y);
        }
        
        // B. Resample
        const step = len / (targetCount - 1);
        let resampled = [points[0]];
        let currentDist = 0;
        
        // Simple resampling: just pick points roughly
        // (Production: use linear interpolation for exact spacing)
        
        // C. Scale to 0..1
        if(isAlreadyScaled) return points; // Simply return if database

        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        points.forEach(p => {
            minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
            minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
        });
        
        const w = maxX - minX || 1;
        const h = maxY - minY || 1;
        
        // Generate simplified vector
        const vector = [];
        for(let i=0; i<targetCount; i++) {
            // Pick index roughly
            const idx = Math.floor(i * (points.length-1) / (targetCount-1));
            const p = points[idx];
            vector.push({
                x: (p.x - minX) / w,
                y: (p.y - minY) / h
            });
        }
        return vector;
    }

    function getScore(vecA, vecB) {
        let sum = 0;
        // Compare point by point
        for(let i=0; i<vecA.length; i++) {
            const dx = vecA[i].x - vecB[i].x;
            const dy = vecA[i].y - vecB[i].y;
            sum += (dx*dx + dy*dy);
        }
        return sum / vecA.length;
    }

    // --- VISUALIZATION & LINKING ---

    function snapToMatch(match, originalPath) {
        // 1. Get Bounding Box of user drawing to position the result
        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        originalPath.forEach(p => {
            minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
            minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
        });
        const w = maxX - minX;
        const h = maxY - minY;

        // 2. Clear Canvas & Draw "Ghost" of user input
        renderStarField();
        ctx.strokeStyle = "rgba(255,255,255,0.1)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        originalPath.forEach((p,i) => i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y));
        ctx.stroke();

        // 3. ANIMATE "MAGNETIC SNAP"
        // We draw the perfect shape overlaying the user's messy shape
        
        const perfectPath = match.points.map(p => ({
            x: minX + (p[0] * w),
            y: minY + (p[1] * h)
        }));

        let progress = 0;
        function animateSnap() {
            progress += 0.05;
            const glow = Math.sin(progress * Math.PI) * 20; // Pulse
            
            // Redraw only the match line (on top of static background)
            // Note: In a complex engine we'd use layers. Here we just redraw it.
            
            ctx.strokeStyle = match.color;
            ctx.lineWidth = 4;
            ctx.shadowColor = match.color;
            ctx.shadowBlur = 15 + glow;
            ctx.lineJoin = "round";
            
            ctx.beginPath();
            perfectPath.forEach((p, i) => {
                if(i===0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
            
            // Draw Stars at vertices
            perfectPath.forEach(p => {
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;

            if(progress < 1) requestAnimationFrame(animateSnap);
        }
        animateSnap();

        // 4. UPDATE HUD WITH LINK
        statusBox.innerHTML = `MATCH CONFIRMED: <span style="color:${match.color}">${match.name}</span>`;
        
        // Construct NOIRLab URL
        const url = `https://noirlab.edu/public/education/constellations/${match.slug}/`;
        
        discoveryLink.href = url;
        discoveryLink.innerText = `EXPLORE ${match.name.toUpperCase()}`;
        discoveryLink.style.display = "inline-block";
    }


    // ==========================================
    // 4. COLOR MODE (Spectrum)
    // ==========================================
    document.addEventListener('mousemove', (e) => {
        if(mode !== 'color') return;
        
        // Visual Feedback
        const hue = (e.clientX / width) * 360;
        const color = `hsl(${hue}, 80%, 60%)`;
        spectrumLayer.style.background = `radial-gradient(circle at ${e.clientX}px ${e.clientY}px, ${color}, transparent 50%)`;
        statusBox.style.borderColor = color;
    });

    document.addEventListener('dblclick', (e) => {
        if(mode !== 'color') return;
        const hue = (e.clientX / width) * 360;
        
        // Find closest hue
        let best = telescopePhotos[0];
        let minDiff = 360;
        
        telescopePhotos.forEach(photo => {
            let diff = Math.abs(photo.hue - hue);
            if(diff > 180) diff = 360 - diff;
            if(diff < minDiff) {
                minDiff = diff;
                best = photo;
            }
        });

        // Open Modal
        document.getElementById('reveal-img').src = best.url;
        document.getElementById('photo-caption').innerText = best.name;
        photoModal.style.opacity = 1;
        photoModal.style.pointerEvents = "auto";
    });

    function closePhoto() {
        photoModal.style.opacity = 0;
        photoModal.style.pointerEvents = "none";
    }

    // ==========================================
    // 5. BACKGROUND
    // ==========================================
    function renderStarField() {
        ctx.clearRect(0,0,width,height);
        ctx.fillStyle = "white";
        for(let i=0; i<150; i++) {
            const x = Math.random()*width;
            const y = Math.random()*height;
            const r = Math.random()*1.5;
            ctx.globalAlpha = Math.random()*0.8+0.2;
            ctx.beginPath();
            ctx.arc(x,y,r,0,Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

</script>
</body>
</html>